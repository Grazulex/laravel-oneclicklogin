
Laravel OneClickLogin — Specification (v0.1)
===========================================

Author: @Grazulex (Jean‑Marc Strauven)
Date: 2025-08-25

Overview
--------
Laravel OneClickLogin provides passwordless authentication via “magic links”: single-use, time-limited URLs sent to users by email or SMS. It focuses on developer ergonomics, security-by-default, and native integration with Laravel’s Auth, Notifications, and Middleware stack. It also integrates cleanly with Grazulex packages like MultiPersona (context/role/tenant switching) and ShareLink (link delivery/observability).

Goals
-----
1) Replace or complement password-based login with one-click, email/SMS-based authentication.
2) Be safe-by-default: signed, hashed tokens; short expirations; single-use; revocation; optional OTP step-up.
3) Offer first-class DX: Facade, fluent builder, artisan commands, events, test helpers.
4) Integrate with MultiPersona: include persona/tenant in the link context.
5) Play nicely with ShareLink: optional delivery layer, audit trails, analytics.

Core Features
-------------
- Magic Link issue & delivery
  - Create signed single-use tokens.
  - Configure expiration (minutes), max uses (default 1), optional IP/device binding.
  - Deliver via Mail (default), SMS (via Notification), or custom channels.
- Validation & login
  - Route/controller to validate tokens and authenticate via Auth::login($user).
  - Middleware to guard routes that accept magic links.
- Security
  - Token signing + hashing at rest (DB).
  - Short default TTL (e.g., 15 minutes).
  - One-time use with atomic consumption.
  - Attempt/usage counters; rate limiting; optional device/IP binding.
  - Optional step-up with OTP if device looks suspicious.
- MultiPersona Integration
  - Embed persona/tenant/role context in the token payload and restore on login.
- Observability
  - Events (created/used/expired/revoked), audit table with timestamps & meta.
- DX
  - Facade + fluent API, Notifications ready-to-customize, Mailables + View stubs.
  - Artisan commands for issuing/sending/testing.
  - Config file with sensible defaults.
  - Pest test utilities.

Domain Model
------------
Table: oneclick_magic_links
- id (ULID/UUID)
- user_id (morphs or foreignId) — supports polymorphic “authenticatable” models.
- email (nullable) — denormalized contact; useful if user not yet persisted.
- token_hash (string) — hash of the raw token; never store the raw token.
- expires_at (datetime) — validity window.
- max_uses (unsigned smallint) — default 1.
- used_count (unsigned smallint) — default 0.
- revoked_at (nullable datetime)
- last_used_at (nullable datetime)
- ip_lock (nullable string) — store request IP if IP binding enabled.
- device_lock (nullable string) — stored fingerprint (user agent hash, etc.).
- context (json) — persona, tenant, role, redirect URL, remember flag, etc.
- meta (json) — arbitrary metadata (utm, campaign, issuer). 
- created_at, updated_at

Token format & storage
- Raw token is generated as a random 32+ bytes, base64url-encoded, appended with ULID ID (e.g., {id}.{token}).
- Only the hash (e.g., SHA-256) is stored in DB. The raw token is sent to the user.
- Validation compares hash(token) with token_hash and checks all invariants (TTL, uses, revoked, IP/device if enabled).

Configuration (config/oneclicklogin.php)
----------------------------------------
- ttl_minutes: 15
- max_uses: 1
- signed_route_name: 'oneclicklogin.consume'
- guard: 'web'
- ip_binding: false
- device_binding: false
- enable_otp_step_up: false
- otp_provider: null
- multi_persona: [
    'enabled' => true,
    'keys' => ['persona', 'tenant', 'role']
  ]
- redirect_after_login: '/'
- redirect_on_invalid: '/login?invalid=1'
- notifications: [
    'mail' => App\Notifications\MagicLinkMail::class,
    'sms'  => App\Notifications\MagicLinkSms::class
  ]
- rate_limit: [
    'issue_per_email_per_hour' => 5,
    'consume_per_ip_per_min'   => 20
  ]

Public API (Facade + Builder)
-----------------------------
Examples:
OneClickLogin::to($user)
    ->via('mail')              // 'mail' | 'sms' | 'notification:<class>'
    ->expireIn(15)             // minutes
    ->maxUses(1)               // default 1
    ->withContext([
        'persona' => 'client',
        'tenant'  => 123,
        'role'    => 'admin',
        'redirect'=> '/dashboard',
        'remember'=> true
    ])
    ->bindIp()                 // optional
    ->bindDevice($request)     // optional (hash UA + OS + etc.)
    ->send();                  // creates DB row, dispatches notification

Issuing without sending:
$link = OneClickLogin::create($user, options: [
    'ttl' => 30,
    'context' => ['redirect' => '/billing'],
]);

Consuming:
- GET /login/magic?token={id}.{raw}  (signed route if desired)
- Controller: MagicLinkController@consume
- Outcome: validates and Auth::login($user, $remember)->redirectTo(context.redirect || config.default)

Routes & Middleware
-------------------
Routes:
Route::get('/login/magic', [MagicLinkController::class, 'consume'])->name('oneclicklogin.consume');

Middleware:
- EnsureMagicLinkIsValid: Extracts token, loads link by id, validates hash/ttl/uses/revocation/ip/device.
- Optionally emit event and short-circuit with redirect_on_invalid on failure.

Events
------
- MagicLinkCreated (link_id, user_id, context)
- MagicLinkSent (link_id, user_id, channel)
- MagicLinkUsed (link_id, user_id, ip, device)
- MagicLinkExpired (link_id)
- MagicLinkRevoked (link_id, by_user_id/null)

Notifications
-------------
Mail example (blade view variables):
- app_name, user_name, magic_url, expires_in, device_hint.
SMS example: short template with clickable URL (ensure short domain best-practice).

Revocation & Expiry
-------------------
- revoke($linkId): sets revoked_at now()
- expire job: scheduled command to mark past-due links as expired (optional maintenance)
- Atomic consume: increment used_count in a transaction and refuse if >= max_uses.

Security Considerations
-----------------------
- Never store raw tokens. Hash with SHA-256 or bcrypt/argon2id (bcrypt is fine for 43–64 chars).
- Short TTL (default 15 minutes) and single-use by default.
- Optional IP/device binding for stricter environments.
- Link signing (via signed routes) protects URL tampering, but token validation is the main gate.
- Step-up with OTP for suspicious access (unknown device/IP, geo anomaly).
- Brute-force protection: rate limits for issue & consume; early exit on malformed tokens.
- Open redirect prevention: validate redirect param against an allowlist or relative paths only.
- XSS/CSRF: login flow should be idempotent and CSRF-exempt for the GET consume route; ensure redirects use 303 or 302 safely.
- Logging: avoid logging raw tokens; log only link_id + user_id + outcome.

Integration: MultiPersona
-------------------------
- If context includes persona/tenant/role, call MultiPersona service after Auth::login:
  MultiPersona::activate(user: $user, persona: 'client', tenantId: 123, role: 'admin');
- Provide graceful fallback if MultiPersona is not installed (no-op).

Integration: ShareLink (optional)
---------------------------------
- Use ShareLink delivery drivers to send magic URLs (benefits: analytics, revocation dashboards).
- Keep OneClickLogin canonical source of truth for auth tokens; use ShareLink as a delivery/logging layer only.

Artisan Commands
----------------
- php artisan oneclick:send {email|user_id} {--via=mail|sms} {--ttl=15} {--uses=1} {--persona=} {--tenant=} {--role=} {--redirect=/}
- php artisan oneclick:revoke {id}
- php artisan oneclick:purge-expired
- php artisan oneclick:test {email}  // issues & prints URL to console for quick QA

Controller Sketch
-----------------
public function consume(Request $request)
{
    $raw = $request->query('token'); // expected "{id}.{token}"
    $result = app(\Grazulex\OneClickLogin\Services\MagicConsumer::class)->consume($raw, $request);

    if (! $result->valid) {
        return redirect(config('oneclicklogin.redirect_on_invalid'));
    }

    Auth::guard(config('oneclicklogin.guard'))->login($result->user, $result->remember);
    
    if ($result->hasPersonaContext()) {
        // Optional integration
        // MultiPersona::activate(...);
    }

    return redirect($result->redirect ?? config('oneclicklogin.redirect_after_login'));
}

Testing Strategy (Pest)
----------------------
- Unit
  - Token generator: length, entropy, hashing, signed URL building.
  - Validator: TTL, max_uses, revocation, IP/device match, rate limit.
- Feature
  - Issue & send email; assert queued notification; assert blade view vars.
  - Consume route: success → authenticated; invalid → redirected to invalid.
  - MultiPersona context: assert persona activation when package present.
- Security
  - Brute-force attempts are rate-limited.
  - Open redirect attempts are blocked (allowlist).
  - Tokens are never logged; only IDs and outcomes are logged.

Example: Quick Start
--------------------
1) Install & Publish
   composer require grazulex/laravel-oneclicklogin
   php artisan vendor:publish --tag=oneclicklogin-config
   php artisan migrate
2) Issue a link
   OneClickLogin::to(User::whereEmail('user@example.com')->first())
     ->via('mail')
     ->expireIn(15)
     ->withContext(['redirect' => '/dashboard'])
     ->send();
3) Handle the consume route (default controller provided).
4) (Optional) Integrate MultiPersona if contexts are used.

Views & Stubs
-------------
- resources/views/vendor/oneclicklogin/mail.blade.php
- resources/views/vendor/oneclicklogin/sms.blade.php (string template if using Vonage/Twilio)
- Configurable subject lines and copy. Provide Tailwind-ready markdown mailable.

Extensibility
-------------
- Custom Token Store: swap repository (DB, Redis, DynamoDB) via interface.
- Custom Notifications: set notification classes in config.
- Custom Policies: hook into events to enforce additional business rules.
- Custom Context: add arbitrary key/values; stored in JSON column.

Roadmap (v0.2+)
---------------
- Device fingerprint abstraction + “trusted device” cookie.
- Admin dashboard (Nova/Filament) to browse issued links and revoke.
- WebAuthn or Passkeys bridging (passwordless 2.0).
- First-class ShareLink driver with analytics.
- Multi-tenant guards support (config per guard).

License
-------
MIT (proposed).

Name & Namespace
----------------
Package name: grazulex/laravel-oneclicklogin
Namespace: Grazulex\OneClickLogin\...

Directory Structure (proposal)
------------------------------
/src
  /Http/Controllers/MagicLinkController.php
  /Http/Middleware/EnsureMagicLinkIsValid.php
  /Models/MagicLink.php
  /Notifications/MagicLinkMail.php
  /Notifications/MagicLinkSms.php
  /Services/MagicIssuer.php
  /Services/MagicConsumer.php
  /Facades/OneClickLogin.php
  /OneClickLoginServiceProvider.php
/database/migrations/2025_01_01_000000_create_oneclick_magic_links_table.php
/config/oneclicklogin.php
/resources/views/mail.blade.php
/resources/views/sms.blade.php
/tests

Copywriting Snippets (User-Facing)
----------------------------------
Email subject: "Sign in to {{ app_name }}"
Email body (headline): "Here’s your one‑click sign in"
CTA: "Sign me in"
Footer: "This link expires in {{ minutes }} minutes. If you didn’t request it, you can ignore this email."

Notes
-----
- Prefer relative redirects to avoid open redirect vulnerabilities.
- Consider using ULIDs for nicer URLs and chronological sorting.
- Expose a small JS to pass device hints (UA hash) if enabling device binding.
